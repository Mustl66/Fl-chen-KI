import plotly.graph_objects as go

# Platten-Daten (Name und (Breite, Höhe))
plate_data = [
    ("A", (1.2, 0.5)),
    ("B", (1.0, 0.3)),
    ("C", (0.6, 0.25)),
    ("D", (0.3, 0.25)),
]

# Große Fläche (Breite, Höhe)
large_area = (3, 3)

def overlaps(x, y, w, h, placed):
    """Überprüft, ob ein Rechteck an (x,y) mit Breite w und Höhe h mit bereits platzierten Rechtecken überlappt."""
    for (_, px, py, pw, ph) in placed:
        if not (x + w <= px or x >= px + pw or y + h <= py or y >= py + ph):
            return True
    return False

def bottom_left_pack(large_area, plate_data):
    """
    Platziert Platten in der großen Fläche mit einer Bottom-Left-Heuristik.
    Für jeden Kandidaten wird geprüft, ob eine Platte (in beiden Orientierungen) dort platziert werden kann.
    Neue Kandidatenpositionen werden bei jeder Platzierung generiert.
    """
    large_width, large_height = large_area
    placed = []  # Liste der platzierten Platten: (Name, x, y, Breite, Höhe)
    candidates = [(0, 0)]  # Startposition

    # Solange es Kandidaten gibt, an denen noch etwas platziert werden kann
    while True:
        best_placement = None
        best_candidate = None
        best_value = None  # Bewertung: (y, x) – niedrigste y hat Priorität, dann x

        # Für jede Kandidatenposition prüfen wir alle Platten (inklusive Rotation)
        for candidate in candidates:
            cx, cy = candidate
            for plate in plate_data:
                # Probiere beide Orientierungen
                for rotated in [False, True]:
                    p_name, (w, h) = plate if not rotated else (plate[0], (plate[1][1], plate[1][0]))
                    # Prüfe, ob die Platte in der großen Fläche passt
                    if cx + w <= large_width and cy + h <= large_height:
                        # Prüfe Überlappung mit bereits platzierten Platten
                        if not overlaps(cx, cy, w, h, placed):
                            candidate_value = (cy, cx)  # "Bottom-Left": zuerst niedrigste y, dann niedrigste x
                            if best_value is None or candidate_value < best_value:
                                best_value = candidate_value
                                best_placement = (p_name, cx, cy, w, h)
                                best_candidate = candidate

        # Falls keine weitere Platte platziert werden kann, beenden
        if best_placement is None:
            break
        else:
            # Platte platzieren
            placed.append(best_placement)
            # Entferne die benutzte Kandidatenposition
            if best_candidate in candidates:
                candidates.remove(best_candidate)
            # Neue Kandidatenpositionen generieren:
            new_positions = [
                (best_placement[1] + best_placement[3], best_placement[2]),  # rechts neben der Platte
                (best_placement[1], best_placement[2] + best_placement[4])   # oberhalb der Platte
            ]
            for pos in new_positions:
                if pos not in candidates:
                    candidates.append(pos)
            # Optionale Bereinigung: Entferne Kandidaten, die bereits von einer platzierten Platte überdeckt werden
            candidates = [pos for pos in candidates
                          if not any(pos[0] >= p[1] and pos[0] < p[1] + p[3] and
                                     pos[1] >= p[2] and pos[1] < p[2] + p[4] for p in placed)]
            # Sortiere Kandidaten, sodass die am weitesten links und unten zuerst kommen
            candidates.sort(key=lambda pos: (pos[1], pos[0]))
    return placed

def plot_combination(large_area, combination):
    """Visualisiert die Anordnung der Platten in der großen Fläche."""
    fig = go.Figure()
    colors = ['#4e73df', '#1cc88a', '#36b9cc', '#f6c23e', '#e74a3b', '#858796']
    for i, (plate_name, x, y, w, h) in enumerate(combination):
        fig.add_trace(go.Scatter(
            x=[x, x+w, x+w, x, x],
            y=[y, y, y+h, y+h, y],
            fill="toself",
            fillcolor=colors[i % len(colors)],
            line=dict(color="black", width=2),
            name=plate_name,
            text=plate_name,
            hoverinfo="text",
            showlegend=False
        ))
        # Bezeichnung in der Mitte der Platte
        fig.add_trace(go.Scatter(
            x=[x + w/2],
            y=[y + h/2],
            text=[plate_name],
            mode='text',
            showlegend=False,
            textfont=dict(size=18, color="black")
        ))

    # Darstellung der großen Fläche mit roter Umrandung
    fig.add_trace(go.Scatter(
        x=[0, large_area[0], large_area[0], 0, 0],
        y=[0, 0, large_area[1], large_area[1], 0],
        fill="none",
        line=dict(color="red", width=4),
        name="Große Fläche Umrandung",
        showlegend=False
    ))

    fig.update_layout(
        title="Verbesserte Plattenanordnung",
        title_x=0.5,
        title_font=dict(size=24, color="black", family="Arial"),
        xaxis=dict(
            range=[0, large_area[0]],
            showgrid=False,
            zeroline=False,
            title="Breite (m)",
            title_font=dict(size=16, family="Arial")
        ),
        yaxis=dict(
            range=[0, large_area[1]],
            showgrid=False,
            zeroline=False,
            title="Höhe (m)",
            title_font=dict(size=16, family="Arial")
        ),
        plot_bgcolor="#f4f7fb",
        paper_bgcolor="#f4f7fb",
        showlegend=True,
    )
    fig.show()


# Berechnung der verbesserten Anordnung
placed_combination = bottom_left_pack(large_area, plate_data)
print("Verbesserte Kombination:", placed_combination)

# Berechnung des Flächenanteils, der abgedeckt ist
area_covered = sum(w * h for (_, _, _, w, h) in placed_combination)
total_area = large_area[0] * large_area[1]
coverage_percentage = (area_covered / total_area) * 100
print(f"Abgedeckte Fläche: {coverage_percentage:.2f}%")

# Visualisierung
plot_combination(large_area, placed_combination)
