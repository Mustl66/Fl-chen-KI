import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Klasse für die Platzierungsumgebung
class PlacementEnv:
    def __init__(self, area_width, area_height, plates):
        self.area_width = area_width
        self.area_height = area_height
        self.plates = dict(sorted(plates.items(), key=lambda item: item[1][0] * item[1][1], reverse=True))
        self.reset()

    def reset(self):
        self.grid = np.zeros((int(self.area_height * 100), int(self.area_width * 100)), dtype=bool)
        self.placed_plates = []
        return self._get_state()

    def _get_state(self):
        return np.expand_dims(self.grid, axis=-1)

    def step(self, action):
        plate_name, x, y, rotation = action
        plate_width, plate_height = self.plates[plate_name]
        if rotation == 90:
            plate_width, plate_height = plate_height, plate_width

        x_idx, y_idx = int(x * 100), int(y * 100)
        width_idx, height_idx = int(plate_width * 100), int(plate_height * 100)

        if self._can_place(x_idx, y_idx, width_idx, height_idx):
            self._mark_grid(x_idx, y_idx, width_idx, height_idx)
            self.placed_plates.append((plate_name, x, y, rotation))
            reward = plate_width * plate_height
            done = self._is_fully_covered()
        else:
            reward = -5
            done = False

        return self._get_state(), reward, done, {}

    def _can_place(self, x, y, width, height):
        if x + width > self.grid.shape[1] or y + height > self.grid.shape[0]:
            return False
        for i in range(height):
            for j in range(width):
                if self.grid[y + i, x + j]:
                    return False
        return True

    def _mark_grid(self, x, y, width, height):
        for i in range(height):
            for j in range(width):
                self.grid[y + i, x + j] = True

    def _is_fully_covered(self):
        return np.all(self.grid)

# Zeichne die aktuelle Platzierung
def plot_placement(env, ax):
    ax.clear()
    ax.add_patch(plt.Rectangle((0, 0), env.area_width, env.area_height, color='lightgrey', edgecolor='black'))
    for plate_name, x, y, rotation in env.placed_plates:
        plate_width, plate_height = env.plates[plate_name]
        if rotation == 90:
            plate_width, plate_height = plate_height, plate_width
        rect = patches.Rectangle((x, y), plate_width, plate_height, edgecolor='black', linewidth=1, facecolor='lightblue')
        ax.add_patch(rect)
        text_x = x + plate_width / 2
        text_y = y + plate_height / 2
        ax.text(text_x, text_y, plate_name, color='black', ha='center', va='center', fontsize=10)

    ax.set_xlim(0, env.area_width)
    ax.set_ylim(0, env.area_height)
    ax.set_aspect('equal', adjustable='box')
    plt.draw()
    plt.pause(0.1)

# Funktion zur Bestimmung des nächsten verfügbaren Platzes
def find_next_best_position(env, plate_name, plate_width, plate_height):
    for y in range(env.grid.shape[0]):
        for x in range(env.grid.shape[1]):
            x_float = x / 100
            y_float = y / 100
            if env._can_place(x, y, int(plate_width * 100), int(plate_height * 100)):
                return x_float, y_float
    return None, None

# Funktion zur Platzierung der Platten
def place_plates_in_order(env):
    for plate_name in env.plates.keys():
        plate_width, plate_height = env.plates[plate_name]
        placed = False

        for rotation in [0, 90]:
            if rotation == 90:
                plate_width, plate_height = plate_height, plate_width

            while True:
                x, y = find_next_best_position(env, plate_name, plate_width, plate_height)
                if x is not None and y is not None:
                    action = (plate_name, x, y, rotation)
                    next_state, reward, done, _ = env.step(action)
                    plot_placement(env, ax)  # Zeige die aktuelle Platzierung
                    if done:  # Wenn der Platz vollständig abgedeckt ist
                        print(f"Abdeckung abgeschlossen mit Platte {plate_name}")
                        return True
                    placed = True
                else:
                    break  # Keine Platzierung möglich in dieser Rotation

        if not placed:
            print(f"Platte {plate_name} konnte nicht platziert werden.")

    if not env._is_fully_covered():
        print("Die Fläche konnte nicht vollständig abgedeckt werden.")

# Hauptprogramm
if __name__ == "__main__":
    # Parameter
    area_width = 10.6
    area_height = 6.25
    plates = {
        "A": (1.2, 0.5),
        "B": (1.0, 0.3),
        "C": (0.6, 0.25),
        "D": (0.3, 0.25)
    }

    env = PlacementEnv(area_width, area_height, plates)

    # Plot Setup
    plt.ion()
    fig, ax = plt.subplots(figsize=(10, 8))
    plt.show()

    # Platzierung der Platten
    env.reset()
    place_plates_in_order(env)

    # Plot der Endplatzierung anzeigen
    plot_placement(env, ax)
    plt.ioff()
    plt.show()
